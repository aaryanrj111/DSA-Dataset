Subset Sum Problem 
Solution 1: Recursive Approach
1. Return true when sum becomes exactly 0 [1 mark]
2. Return false when no elements remain and sum is not 0 [1 mark]
3. Skip current element when its value exceeds remaining sum [2 marks]
4. Handle boundary checks to prevent array index out of bounds [1 mark]
5. Exclude the current element (recursive call with n-1 and unchanged sum) [1 mark]
6. Include the current element (recursive call with n-1 and reduced sum) [1 mark]
7. Properly combine results with logical OR operation [1 mark]
8. Structure recursive calls to minimize redundant calculations [1 mark]
Solution 2: Top-Down DP (Memoization)
1. Initialize a 2D array of size (n+1)×(sum+1) with sentinel values [1 mark]
2. Correctly index the array to match subproblem parameters [1 mark]
3. Check memo array before computing a subproblem [1 mark]
4. Return stored result when available [1 mark]
5. Correctly handle base cases with memoization [1 mark]
6. Properly implement the include/exclude choices [2 marks]
7. Store computed results in the memo array at the correct indices [1 mark]
8. Ensure all paths update the memoization table properly before returning [1 mark]
Solution 3: Bottom-Up DP (Tabulation)
1. Allocate a 2D boolean array of size (n+1)×(sum+1) [1 mark]
2. Initialize first column (sum=0) to true for all rows [1 mark]
3. Initialize first row appropriately (except dp[0][0]) [1 mark]
4. Process elements in sequence from 1 to n [1 mark]
5. Evaluate all possible sums from 1 to target sum [1 mark]
6. When current element value > current sum: dp[i][j] = dp[i-1][j] [2 marks]
7. Otherwise: dp[i][j] = dp[i-1][j] OR dp[i-1][j-arr[i-1]] [2 marks]
8. Return the final result from the correct cell dp[n][sum] [1 mark]
Solution 4: Space-Optimized DP
1. Allocate two 1D boolean arrays ('prev' and 'curr') of size (sum+1) [1 mark]
2. Correctly initialize prev[0] = true and other elements as needed [1 mark]
3. Maintain proper offset for element access in the input array [1 mark]
4. Handle boundary conditions when updating the arrays [1 mark]
5. When current element value > current sum: curr[j] = prev[j] [2 marks]
6. Otherwise: curr[j] = prev[j] OR prev[j-arr[i]] [2 marks]
7. Efficiently transfer values from 'curr' to 'prev' for next iteration [1 mark]
8. Avoid unnecessary copying of unchanged values [1 mark]